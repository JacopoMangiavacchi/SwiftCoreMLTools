// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SVM.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A linear kernel.
///
/// This function has the following formula:
///
/// .. math::
///     K(\boldsymbol{x}, \boldsymbol{x'}) = \boldsymbol{x}^T \boldsymbol{x'}
struct CoreML_Specification_LinearKernel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A Gaussian radial basis function (RBF) kernel.
///
/// This function has the following formula:
///
/// .. math::
///     K(\boldsymbol{x}, \boldsymbol{x'}) = \
///          \exp(-\gamma || \boldsymbol{x} - \boldsymbol{x'} ||^2 )
struct CoreML_Specification_RBFKernel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gamma: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A polynomial kernel.
///
/// This function has the following formula:
///
/// .. math::
///     K(\boldsymbol{x}, \boldsymbol{x'}) = \
///           (\gamma \boldsymbol{x}^T \boldsymbol{x'} + c)^{degree}
struct CoreML_Specification_PolyKernel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var degree: Int32 = 0

  var c: Double = 0

  var gamma: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A sigmoid kernel.
///
/// This function has the following formula:
///
/// .. math::
///     K(\boldsymbol{x}, \boldsymbol{x'}) = \
///           \tanh(\gamma \boldsymbol{x}^T \boldsymbol{x'} + c)
struct CoreML_Specification_SigmoidKernel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gamma: Double = 0

  var c: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A kernel.
struct CoreML_Specification_Kernel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kernel: OneOf_Kernel? {
    get {return _storage._kernel}
    set {_uniqueStorage()._kernel = newValue}
  }

  var linearKernel: CoreML_Specification_LinearKernel {
    get {
      if case .linearKernel(let v)? = _storage._kernel {return v}
      return CoreML_Specification_LinearKernel()
    }
    set {_uniqueStorage()._kernel = .linearKernel(newValue)}
  }

  var rbfKernel: CoreML_Specification_RBFKernel {
    get {
      if case .rbfKernel(let v)? = _storage._kernel {return v}
      return CoreML_Specification_RBFKernel()
    }
    set {_uniqueStorage()._kernel = .rbfKernel(newValue)}
  }

  var polyKernel: CoreML_Specification_PolyKernel {
    get {
      if case .polyKernel(let v)? = _storage._kernel {return v}
      return CoreML_Specification_PolyKernel()
    }
    set {_uniqueStorage()._kernel = .polyKernel(newValue)}
  }

  var sigmoidKernel: CoreML_Specification_SigmoidKernel {
    get {
      if case .sigmoidKernel(let v)? = _storage._kernel {return v}
      return CoreML_Specification_SigmoidKernel()
    }
    set {_uniqueStorage()._kernel = .sigmoidKernel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kernel: Equatable {
    case linearKernel(CoreML_Specification_LinearKernel)
    case rbfKernel(CoreML_Specification_RBFKernel)
    case polyKernel(CoreML_Specification_PolyKernel)
    case sigmoidKernel(CoreML_Specification_SigmoidKernel)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_Kernel.OneOf_Kernel, rhs: CoreML_Specification_Kernel.OneOf_Kernel) -> Bool {
      switch (lhs, rhs) {
      case (.linearKernel(let l), .linearKernel(let r)): return l == r
      case (.rbfKernel(let l), .rbfKernel(let r)): return l == r
      case (.polyKernel(let l), .polyKernel(let r)): return l == r
      case (.sigmoidKernel(let l), .sigmoidKernel(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A sparse node.
struct CoreML_Specification_SparseNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 1-based indexes, like libsvm
  var index: Int32 = 0

  var value: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A sparse vector.
struct CoreML_Specification_SparseVector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [CoreML_Specification_SparseNode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// One or more sparse support vectors.
struct CoreML_Specification_SparseSupportVectors {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vectors: [CoreML_Specification_SparseVector] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A dense vector.
struct CoreML_Specification_DenseVector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// One or more dense support vectors.
struct CoreML_Specification_DenseSupportVectors {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vectors: [CoreML_Specification_DenseVector] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// One or more coefficients.
struct CoreML_Specification_Coefficients {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alpha: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A support vector regressor.
struct CoreML_Specification_SupportVectorRegressor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kernel: CoreML_Specification_Kernel {
    get {return _storage._kernel ?? CoreML_Specification_Kernel()}
    set {_uniqueStorage()._kernel = newValue}
  }
  /// Returns true if `kernel` has been explicitly set.
  var hasKernel: Bool {return _storage._kernel != nil}
  /// Clears the value of `kernel`. Subsequent reads from it will return its default value.
  mutating func clearKernel() {_uniqueStorage()._kernel = nil}

  /// Support vectors, either sparse or dense format
  var supportVectors: OneOf_SupportVectors? {
    get {return _storage._supportVectors}
    set {_uniqueStorage()._supportVectors = newValue}
  }

  var sparseSupportVectors: CoreML_Specification_SparseSupportVectors {
    get {
      if case .sparseSupportVectors(let v)? = _storage._supportVectors {return v}
      return CoreML_Specification_SparseSupportVectors()
    }
    set {_uniqueStorage()._supportVectors = .sparseSupportVectors(newValue)}
  }

  var denseSupportVectors: CoreML_Specification_DenseSupportVectors {
    get {
      if case .denseSupportVectors(let v)? = _storage._supportVectors {return v}
      return CoreML_Specification_DenseSupportVectors()
    }
    set {_uniqueStorage()._supportVectors = .denseSupportVectors(newValue)}
  }

  /// Coefficients, one for each support vector
  var coefficients: CoreML_Specification_Coefficients {
    get {return _storage._coefficients ?? CoreML_Specification_Coefficients()}
    set {_uniqueStorage()._coefficients = newValue}
  }
  /// Returns true if `coefficients` has been explicitly set.
  var hasCoefficients: Bool {return _storage._coefficients != nil}
  /// Clears the value of `coefficients`. Subsequent reads from it will return its default value.
  mutating func clearCoefficients() {_uniqueStorage()._coefficients = nil}

  var rho: Double {
    get {return _storage._rho}
    set {_uniqueStorage()._rho = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Support vectors, either sparse or dense format
  enum OneOf_SupportVectors: Equatable {
    case sparseSupportVectors(CoreML_Specification_SparseSupportVectors)
    case denseSupportVectors(CoreML_Specification_DenseSupportVectors)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_SupportVectorRegressor.OneOf_SupportVectors, rhs: CoreML_Specification_SupportVectorRegressor.OneOf_SupportVectors) -> Bool {
      switch (lhs, rhs) {
      case (.sparseSupportVectors(let l), .sparseSupportVectors(let r)): return l == r
      case (.denseSupportVectors(let l), .denseSupportVectors(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A support vector classifier
struct CoreML_Specification_SupportVectorClassifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kernel: CoreML_Specification_Kernel {
    get {return _storage._kernel ?? CoreML_Specification_Kernel()}
    set {_uniqueStorage()._kernel = newValue}
  }
  /// Returns true if `kernel` has been explicitly set.
  var hasKernel: Bool {return _storage._kernel != nil}
  /// Clears the value of `kernel`. Subsequent reads from it will return its default value.
  mutating func clearKernel() {_uniqueStorage()._kernel = nil}

  ///*
  /// The number of support vectors for each class.
  var numberOfSupportVectorsPerClass: [Int32] {
    get {return _storage._numberOfSupportVectorsPerClass}
    set {_uniqueStorage()._numberOfSupportVectorsPerClass = newValue}
  }

  ///*
  /// The support vectors, in either sparse or dense format.
  var supportVectors: OneOf_SupportVectors? {
    get {return _storage._supportVectors}
    set {_uniqueStorage()._supportVectors = newValue}
  }

  var sparseSupportVectors: CoreML_Specification_SparseSupportVectors {
    get {
      if case .sparseSupportVectors(let v)? = _storage._supportVectors {return v}
      return CoreML_Specification_SparseSupportVectors()
    }
    set {_uniqueStorage()._supportVectors = .sparseSupportVectors(newValue)}
  }

  var denseSupportVectors: CoreML_Specification_DenseSupportVectors {
    get {
      if case .denseSupportVectors(let v)? = _storage._supportVectors {return v}
      return CoreML_Specification_DenseSupportVectors()
    }
    set {_uniqueStorage()._supportVectors = .denseSupportVectors(newValue)}
  }

  ///*
  /// The coefficients, essentially a two dimensional array of
  /// size: (numberOfClasses-1) by (total number of support vectors)
  var coefficients: [CoreML_Specification_Coefficients] {
    get {return _storage._coefficients}
    set {_uniqueStorage()._coefficients = newValue}
  }

  ///*
  /// Constants for decision function,
  /// with K*(K-1) / 2 elements,
  /// where K is the number of classes.
  var rho: [Double] {
    get {return _storage._rho}
    set {_uniqueStorage()._rho = newValue}
  }

  ///*
  /// Pairwise probability information for A vs B classifier.
  /// Total of K*(K-1)/2 elements where K is the number of classes.
  /// These fields are optional,
  /// and only required if you want probabilities or multi class predictions.
  var probA: [Double] {
    get {return _storage._probA}
    set {_uniqueStorage()._probA = newValue}
  }

  var probB: [Double] {
    get {return _storage._probB}
    set {_uniqueStorage()._probB = newValue}
  }

  ///*
  /// Class label mapping.
  var classLabels: OneOf_ClassLabels? {
    get {return _storage._classLabels}
    set {_uniqueStorage()._classLabels = newValue}
  }

  var stringClassLabels: CoreML_Specification_StringVector {
    get {
      if case .stringClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_StringVector()
    }
    set {_uniqueStorage()._classLabels = .stringClassLabels(newValue)}
  }

  var int64ClassLabels: CoreML_Specification_Int64Vector {
    get {
      if case .int64ClassLabels(let v)? = _storage._classLabels {return v}
      return CoreML_Specification_Int64Vector()
    }
    set {_uniqueStorage()._classLabels = .int64ClassLabels(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The support vectors, in either sparse or dense format.
  enum OneOf_SupportVectors: Equatable {
    case sparseSupportVectors(CoreML_Specification_SparseSupportVectors)
    case denseSupportVectors(CoreML_Specification_DenseSupportVectors)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_SupportVectorClassifier.OneOf_SupportVectors, rhs: CoreML_Specification_SupportVectorClassifier.OneOf_SupportVectors) -> Bool {
      switch (lhs, rhs) {
      case (.sparseSupportVectors(let l), .sparseSupportVectors(let r)): return l == r
      case (.denseSupportVectors(let l), .denseSupportVectors(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  ///*
  /// Class label mapping.
  enum OneOf_ClassLabels: Equatable {
    case stringClassLabels(CoreML_Specification_StringVector)
    case int64ClassLabels(CoreML_Specification_Int64Vector)

  #if !swift(>=4.1)
    static func ==(lhs: CoreML_Specification_SupportVectorClassifier.OneOf_ClassLabels, rhs: CoreML_Specification_SupportVectorClassifier.OneOf_ClassLabels) -> Bool {
      switch (lhs, rhs) {
      case (.stringClassLabels(let l), .stringClassLabels(let r)): return l == r
      case (.int64ClassLabels(let l), .int64ClassLabels(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_LinearKernel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinearKernel"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_LinearKernel, rhs: CoreML_Specification_LinearKernel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_RBFKernel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RBFKernel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamma"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.gamma)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gamma != 0 {
      try visitor.visitSingularDoubleField(value: self.gamma, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_RBFKernel, rhs: CoreML_Specification_RBFKernel) -> Bool {
    if lhs.gamma != rhs.gamma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_PolyKernel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolyKernel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "degree"),
    2: .same(proto: "c"),
    3: .same(proto: "gamma"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.degree)
      case 2: try decoder.decodeSingularDoubleField(value: &self.c)
      case 3: try decoder.decodeSingularDoubleField(value: &self.gamma)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.degree != 0 {
      try visitor.visitSingularInt32Field(value: self.degree, fieldNumber: 1)
    }
    if self.c != 0 {
      try visitor.visitSingularDoubleField(value: self.c, fieldNumber: 2)
    }
    if self.gamma != 0 {
      try visitor.visitSingularDoubleField(value: self.gamma, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_PolyKernel, rhs: CoreML_Specification_PolyKernel) -> Bool {
    if lhs.degree != rhs.degree {return false}
    if lhs.c != rhs.c {return false}
    if lhs.gamma != rhs.gamma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SigmoidKernel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigmoidKernel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamma"),
    2: .same(proto: "c"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.gamma)
      case 2: try decoder.decodeSingularDoubleField(value: &self.c)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gamma != 0 {
      try visitor.visitSingularDoubleField(value: self.gamma, fieldNumber: 1)
    }
    if self.c != 0 {
      try visitor.visitSingularDoubleField(value: self.c, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SigmoidKernel, rhs: CoreML_Specification_SigmoidKernel) -> Bool {
    if lhs.gamma != rhs.gamma {return false}
    if lhs.c != rhs.c {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_Kernel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Kernel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "linearKernel"),
    2: .same(proto: "rbfKernel"),
    3: .same(proto: "polyKernel"),
    4: .same(proto: "sigmoidKernel"),
  ]

  fileprivate class _StorageClass {
    var _kernel: CoreML_Specification_Kernel.OneOf_Kernel?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kernel = source._kernel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: CoreML_Specification_LinearKernel?
          if let current = _storage._kernel {
            try decoder.handleConflictingOneOf()
            if case .linearKernel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kernel = .linearKernel(v)}
        case 2:
          var v: CoreML_Specification_RBFKernel?
          if let current = _storage._kernel {
            try decoder.handleConflictingOneOf()
            if case .rbfKernel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kernel = .rbfKernel(v)}
        case 3:
          var v: CoreML_Specification_PolyKernel?
          if let current = _storage._kernel {
            try decoder.handleConflictingOneOf()
            if case .polyKernel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kernel = .polyKernel(v)}
        case 4:
          var v: CoreML_Specification_SigmoidKernel?
          if let current = _storage._kernel {
            try decoder.handleConflictingOneOf()
            if case .sigmoidKernel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kernel = .sigmoidKernel(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._kernel {
      case .linearKernel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .rbfKernel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .polyKernel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .sigmoidKernel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_Kernel, rhs: CoreML_Specification_Kernel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kernel != rhs_storage._kernel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SparseNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.index)
      case 2: try decoder.decodeSingularDoubleField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SparseNode, rhs: CoreML_Specification_SparseNode) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SparseVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseVector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SparseVector, rhs: CoreML_Specification_SparseVector) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SparseSupportVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseSupportVectors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vectors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.vectors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SparseSupportVectors, rhs: CoreML_Specification_SparseSupportVectors) -> Bool {
    if lhs.vectors != rhs.vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_DenseVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenseVector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedDoubleField(value: &self.values)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_DenseVector, rhs: CoreML_Specification_DenseVector) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_DenseSupportVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenseSupportVectors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vectors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.vectors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_DenseSupportVectors, rhs: CoreML_Specification_DenseSupportVectors) -> Bool {
    if lhs.vectors != rhs.vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_Coefficients: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Coefficients"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedDoubleField(value: &self.alpha)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alpha.isEmpty {
      try visitor.visitPackedDoubleField(value: self.alpha, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_Coefficients, rhs: CoreML_Specification_Coefficients) -> Bool {
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SupportVectorRegressor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupportVectorRegressor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kernel"),
    2: .same(proto: "sparseSupportVectors"),
    3: .same(proto: "denseSupportVectors"),
    4: .same(proto: "coefficients"),
    5: .same(proto: "rho"),
  ]

  fileprivate class _StorageClass {
    var _kernel: CoreML_Specification_Kernel? = nil
    var _supportVectors: CoreML_Specification_SupportVectorRegressor.OneOf_SupportVectors?
    var _coefficients: CoreML_Specification_Coefficients? = nil
    var _rho: Double = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kernel = source._kernel
      _supportVectors = source._supportVectors
      _coefficients = source._coefficients
      _rho = source._rho
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._kernel)
        case 2:
          var v: CoreML_Specification_SparseSupportVectors?
          if let current = _storage._supportVectors {
            try decoder.handleConflictingOneOf()
            if case .sparseSupportVectors(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._supportVectors = .sparseSupportVectors(v)}
        case 3:
          var v: CoreML_Specification_DenseSupportVectors?
          if let current = _storage._supportVectors {
            try decoder.handleConflictingOneOf()
            if case .denseSupportVectors(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._supportVectors = .denseSupportVectors(v)}
        case 4: try decoder.decodeSingularMessageField(value: &_storage._coefficients)
        case 5: try decoder.decodeSingularDoubleField(value: &_storage._rho)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._kernel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._supportVectors {
      case .sparseSupportVectors(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .denseSupportVectors(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._coefficients {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._rho != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rho, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SupportVectorRegressor, rhs: CoreML_Specification_SupportVectorRegressor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kernel != rhs_storage._kernel {return false}
        if _storage._supportVectors != rhs_storage._supportVectors {return false}
        if _storage._coefficients != rhs_storage._coefficients {return false}
        if _storage._rho != rhs_storage._rho {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_SupportVectorClassifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupportVectorClassifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kernel"),
    2: .same(proto: "numberOfSupportVectorsPerClass"),
    3: .same(proto: "sparseSupportVectors"),
    4: .same(proto: "denseSupportVectors"),
    5: .same(proto: "coefficients"),
    6: .same(proto: "rho"),
    7: .same(proto: "probA"),
    8: .same(proto: "probB"),
    100: .same(proto: "stringClassLabels"),
    101: .same(proto: "int64ClassLabels"),
  ]

  fileprivate class _StorageClass {
    var _kernel: CoreML_Specification_Kernel? = nil
    var _numberOfSupportVectorsPerClass: [Int32] = []
    var _supportVectors: CoreML_Specification_SupportVectorClassifier.OneOf_SupportVectors?
    var _coefficients: [CoreML_Specification_Coefficients] = []
    var _rho: [Double] = []
    var _probA: [Double] = []
    var _probB: [Double] = []
    var _classLabels: CoreML_Specification_SupportVectorClassifier.OneOf_ClassLabels?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kernel = source._kernel
      _numberOfSupportVectorsPerClass = source._numberOfSupportVectorsPerClass
      _supportVectors = source._supportVectors
      _coefficients = source._coefficients
      _rho = source._rho
      _probA = source._probA
      _probB = source._probB
      _classLabels = source._classLabels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._kernel)
        case 2: try decoder.decodeRepeatedInt32Field(value: &_storage._numberOfSupportVectorsPerClass)
        case 3:
          var v: CoreML_Specification_SparseSupportVectors?
          if let current = _storage._supportVectors {
            try decoder.handleConflictingOneOf()
            if case .sparseSupportVectors(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._supportVectors = .sparseSupportVectors(v)}
        case 4:
          var v: CoreML_Specification_DenseSupportVectors?
          if let current = _storage._supportVectors {
            try decoder.handleConflictingOneOf()
            if case .denseSupportVectors(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._supportVectors = .denseSupportVectors(v)}
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._coefficients)
        case 6: try decoder.decodeRepeatedDoubleField(value: &_storage._rho)
        case 7: try decoder.decodeRepeatedDoubleField(value: &_storage._probA)
        case 8: try decoder.decodeRepeatedDoubleField(value: &_storage._probB)
        case 100:
          var v: CoreML_Specification_StringVector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .stringClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .stringClassLabels(v)}
        case 101:
          var v: CoreML_Specification_Int64Vector?
          if let current = _storage._classLabels {
            try decoder.handleConflictingOneOf()
            if case .int64ClassLabels(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._classLabels = .int64ClassLabels(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._kernel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._numberOfSupportVectorsPerClass.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._numberOfSupportVectorsPerClass, fieldNumber: 2)
      }
      switch _storage._supportVectors {
      case .sparseSupportVectors(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .denseSupportVectors(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
      if !_storage._coefficients.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._coefficients, fieldNumber: 5)
      }
      if !_storage._rho.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._rho, fieldNumber: 6)
      }
      if !_storage._probA.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._probA, fieldNumber: 7)
      }
      if !_storage._probB.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._probB, fieldNumber: 8)
      }
      switch _storage._classLabels {
      case .stringClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .int64ClassLabels(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_SupportVectorClassifier, rhs: CoreML_Specification_SupportVectorClassifier) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kernel != rhs_storage._kernel {return false}
        if _storage._numberOfSupportVectorsPerClass != rhs_storage._numberOfSupportVectorsPerClass {return false}
        if _storage._supportVectors != rhs_storage._supportVectors {return false}
        if _storage._coefficients != rhs_storage._coefficients {return false}
        if _storage._rho != rhs_storage._rho {return false}
        if _storage._probA != rhs_storage._probA {return false}
        if _storage._probB != rhs_storage._probB {return false}
        if _storage._classLabels != rhs_storage._classLabels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
