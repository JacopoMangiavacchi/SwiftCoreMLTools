// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BayesianProbitRegressor.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CoreML_Specification_BayesianProbitRegressor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberOfFeatures: UInt32 {
    get {return _storage._numberOfFeatures}
    set {_uniqueStorage()._numberOfFeatures = newValue}
  }

  /// bias term
  var bias: CoreML_Specification_BayesianProbitRegressor.Gaussian {
    get {return _storage._bias ?? CoreML_Specification_BayesianProbitRegressor.Gaussian()}
    set {_uniqueStorage()._bias = newValue}
  }
  /// Returns true if `bias` has been explicitly set.
  var hasBias: Bool {return _storage._bias != nil}
  /// Clears the value of `bias`. Subsequent reads from it will return its default value.
  mutating func clearBias() {_uniqueStorage()._bias = nil}

  ///
  /// Set of features with associated weights
  var features: [CoreML_Specification_BayesianProbitRegressor.FeatureWeight] {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  ///
  /// Set this name to be the same as input feature of type multi-array (1D)
  /// in the model description you want to use as the regression input
  var regressionInputFeatureName: String {
    get {return _storage._regressionInputFeatureName}
    set {_uniqueStorage()._regressionInputFeatureName = newValue}
  }

  ///
  /// Set this name to be the same as optional input feature of type double
  /// in the model description you want to use as the optimism input
  var optimismInputFeatureName: String {
    get {return _storage._optimismInputFeatureName}
    set {_uniqueStorage()._optimismInputFeatureName = newValue}
  }

  ///
  /// Set this name to be the same as optional input feature of type double
  /// in the model description you want to use as the samplingScale input
  var samplingScaleInputFeatureName: String {
    get {return _storage._samplingScaleInputFeatureName}
    set {_uniqueStorage()._samplingScaleInputFeatureName = newValue}
  }

  ///
  /// Set this name to be the same as optional input feature of type double
  /// in the model description you want to use as the samplingBounds input
  var samplingTruncationInputFeatureName: String {
    get {return _storage._samplingTruncationInputFeatureName}
    set {_uniqueStorage()._samplingTruncationInputFeatureName = newValue}
  }

  ///
  /// name of 'mean' output feature
  var meanOutputFeatureName: String {
    get {return _storage._meanOutputFeatureName}
    set {_uniqueStorage()._meanOutputFeatureName = newValue}
  }

  ///
  /// name of 'variance' output feature
  var varianceOutputFeatureName: String {
    get {return _storage._varianceOutputFeatureName}
    set {_uniqueStorage()._varianceOutputFeatureName = newValue}
  }

  ///
  /// name of 'pessimistic' output feature
  var pessimisticProbabilityOutputFeatureName: String {
    get {return _storage._pessimisticProbabilityOutputFeatureName}
    set {_uniqueStorage()._pessimisticProbabilityOutputFeatureName = newValue}
  }

  ///
  /// name of 'sampled' output feature: samples from the scaled posterior probability distribuiton
  var sampledProbabilityOutputFeatureName: String {
    get {return _storage._sampledProbabilityOutputFeatureName}
    set {_uniqueStorage()._sampledProbabilityOutputFeatureName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Parameterization of a Gaussian distribution
  struct Gaussian {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mean: Double = 0

    /// inverse of the variance
    var precision: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// Weight for a specific feature value
  /// The weight is represented as a Gaussian distribution
  /// with a mean and precision (1/variance) to capture
  /// uncertainty in the weight
  struct FeatureValueWeight {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var featureValue: UInt32 {
      get {return _storage._featureValue}
      set {_uniqueStorage()._featureValue = newValue}
    }

    var featureWeight: CoreML_Specification_BayesianProbitRegressor.Gaussian {
      get {return _storage._featureWeight ?? CoreML_Specification_BayesianProbitRegressor.Gaussian()}
      set {_uniqueStorage()._featureWeight = newValue}
    }
    /// Returns true if `featureWeight` has been explicitly set.
    var hasFeatureWeight: Bool {return _storage._featureWeight != nil}
    /// Clears the value of `featureWeight`. Subsequent reads from it will return its default value.
    mutating func clearFeatureWeight() {_uniqueStorage()._featureWeight = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  ///
  /// Feature with associated weights (for different values)
  /// Each feature has a set of weights for the (discrete) values
  /// it can take
  struct FeatureWeight {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var featureID: UInt32 = 0

    var weights: [CoreML_Specification_BayesianProbitRegressor.FeatureValueWeight] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_BayesianProbitRegressor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BayesianProbitRegressor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberOfFeatures"),
    2: .same(proto: "bias"),
    3: .same(proto: "features"),
    10: .same(proto: "regressionInputFeatureName"),
    11: .same(proto: "optimismInputFeatureName"),
    12: .same(proto: "samplingScaleInputFeatureName"),
    13: .same(proto: "samplingTruncationInputFeatureName"),
    20: .same(proto: "meanOutputFeatureName"),
    21: .same(proto: "varianceOutputFeatureName"),
    22: .same(proto: "pessimisticProbabilityOutputFeatureName"),
    23: .same(proto: "sampledProbabilityOutputFeatureName"),
  ]

  fileprivate class _StorageClass {
    var _numberOfFeatures: UInt32 = 0
    var _bias: CoreML_Specification_BayesianProbitRegressor.Gaussian? = nil
    var _features: [CoreML_Specification_BayesianProbitRegressor.FeatureWeight] = []
    var _regressionInputFeatureName: String = String()
    var _optimismInputFeatureName: String = String()
    var _samplingScaleInputFeatureName: String = String()
    var _samplingTruncationInputFeatureName: String = String()
    var _meanOutputFeatureName: String = String()
    var _varianceOutputFeatureName: String = String()
    var _pessimisticProbabilityOutputFeatureName: String = String()
    var _sampledProbabilityOutputFeatureName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numberOfFeatures = source._numberOfFeatures
      _bias = source._bias
      _features = source._features
      _regressionInputFeatureName = source._regressionInputFeatureName
      _optimismInputFeatureName = source._optimismInputFeatureName
      _samplingScaleInputFeatureName = source._samplingScaleInputFeatureName
      _samplingTruncationInputFeatureName = source._samplingTruncationInputFeatureName
      _meanOutputFeatureName = source._meanOutputFeatureName
      _varianceOutputFeatureName = source._varianceOutputFeatureName
      _pessimisticProbabilityOutputFeatureName = source._pessimisticProbabilityOutputFeatureName
      _sampledProbabilityOutputFeatureName = source._sampledProbabilityOutputFeatureName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._numberOfFeatures)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._bias)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._features)
        case 10: try decoder.decodeSingularStringField(value: &_storage._regressionInputFeatureName)
        case 11: try decoder.decodeSingularStringField(value: &_storage._optimismInputFeatureName)
        case 12: try decoder.decodeSingularStringField(value: &_storage._samplingScaleInputFeatureName)
        case 13: try decoder.decodeSingularStringField(value: &_storage._samplingTruncationInputFeatureName)
        case 20: try decoder.decodeSingularStringField(value: &_storage._meanOutputFeatureName)
        case 21: try decoder.decodeSingularStringField(value: &_storage._varianceOutputFeatureName)
        case 22: try decoder.decodeSingularStringField(value: &_storage._pessimisticProbabilityOutputFeatureName)
        case 23: try decoder.decodeSingularStringField(value: &_storage._sampledProbabilityOutputFeatureName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._numberOfFeatures != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numberOfFeatures, fieldNumber: 1)
      }
      if let v = _storage._bias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._features.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._features, fieldNumber: 3)
      }
      if !_storage._regressionInputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._regressionInputFeatureName, fieldNumber: 10)
      }
      if !_storage._optimismInputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._optimismInputFeatureName, fieldNumber: 11)
      }
      if !_storage._samplingScaleInputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._samplingScaleInputFeatureName, fieldNumber: 12)
      }
      if !_storage._samplingTruncationInputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._samplingTruncationInputFeatureName, fieldNumber: 13)
      }
      if !_storage._meanOutputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._meanOutputFeatureName, fieldNumber: 20)
      }
      if !_storage._varianceOutputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._varianceOutputFeatureName, fieldNumber: 21)
      }
      if !_storage._pessimisticProbabilityOutputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pessimisticProbabilityOutputFeatureName, fieldNumber: 22)
      }
      if !_storage._sampledProbabilityOutputFeatureName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sampledProbabilityOutputFeatureName, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BayesianProbitRegressor, rhs: CoreML_Specification_BayesianProbitRegressor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numberOfFeatures != rhs_storage._numberOfFeatures {return false}
        if _storage._bias != rhs_storage._bias {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._regressionInputFeatureName != rhs_storage._regressionInputFeatureName {return false}
        if _storage._optimismInputFeatureName != rhs_storage._optimismInputFeatureName {return false}
        if _storage._samplingScaleInputFeatureName != rhs_storage._samplingScaleInputFeatureName {return false}
        if _storage._samplingTruncationInputFeatureName != rhs_storage._samplingTruncationInputFeatureName {return false}
        if _storage._meanOutputFeatureName != rhs_storage._meanOutputFeatureName {return false}
        if _storage._varianceOutputFeatureName != rhs_storage._varianceOutputFeatureName {return false}
        if _storage._pessimisticProbabilityOutputFeatureName != rhs_storage._pessimisticProbabilityOutputFeatureName {return false}
        if _storage._sampledProbabilityOutputFeatureName != rhs_storage._sampledProbabilityOutputFeatureName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BayesianProbitRegressor.Gaussian: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_BayesianProbitRegressor.protoMessageName + ".Gaussian"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mean"),
    2: .same(proto: "precision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.mean)
      case 2: try decoder.decodeSingularDoubleField(value: &self.precision)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 1)
    }
    if self.precision != 0 {
      try visitor.visitSingularDoubleField(value: self.precision, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BayesianProbitRegressor.Gaussian, rhs: CoreML_Specification_BayesianProbitRegressor.Gaussian) -> Bool {
    if lhs.mean != rhs.mean {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BayesianProbitRegressor.FeatureValueWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_BayesianProbitRegressor.protoMessageName + ".FeatureValueWeight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featureValue"),
    2: .same(proto: "featureWeight"),
  ]

  fileprivate class _StorageClass {
    var _featureValue: UInt32 = 0
    var _featureWeight: CoreML_Specification_BayesianProbitRegressor.Gaussian? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _featureValue = source._featureValue
      _featureWeight = source._featureWeight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._featureValue)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._featureWeight)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._featureValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._featureValue, fieldNumber: 1)
      }
      if let v = _storage._featureWeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BayesianProbitRegressor.FeatureValueWeight, rhs: CoreML_Specification_BayesianProbitRegressor.FeatureValueWeight) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._featureValue != rhs_storage._featureValue {return false}
        if _storage._featureWeight != rhs_storage._featureWeight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoreML_Specification_BayesianProbitRegressor.FeatureWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CoreML_Specification_BayesianProbitRegressor.protoMessageName + ".FeatureWeight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "featureId"),
    2: .same(proto: "weights"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.featureID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.weights)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.featureID != 0 {
      try visitor.visitSingularUInt32Field(value: self.featureID, fieldNumber: 1)
    }
    if !self.weights.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weights, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoreML_Specification_BayesianProbitRegressor.FeatureWeight, rhs: CoreML_Specification_BayesianProbitRegressor.FeatureWeight) -> Bool {
    if lhs.featureID != rhs.featureID {return false}
    if lhs.weights != rhs.weights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
